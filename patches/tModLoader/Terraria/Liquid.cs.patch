--- src/TerrariaNetCore/Terraria/Liquid.cs
+++ src/tModLoader/Terraria/Liquid.cs
@@ -1,10 +_,14 @@
 using System;
 using System.Collections.Generic;
+using Terraria;
 using Terraria.GameContent.NetModules;
 using Terraria.ID;
 using Terraria.Localization;
+using Terraria.ModLoader;
 using Terraria.ObjectData;
 using Terraria.WorldBuilding;
+using Terraria.ModLoader;
+using static Terraria.WorldBuilding.Searches;
 
 namespace Terraria;
 
@@ -121,17 +_,22 @@
 		bool flag = tile.honey();
 		bool flag2 = tile.shimmer();
 		int num3 = tile.liquid;
-		byte b = tile.liquidType();
+		ushort b = tile.liquidType();
 		tile.liquid = 0;
 		bool flag3 = true;
 		while (true) {
 			Tile tile2 = Main.tile[num, num2 + 1];
 			bool flag4 = false;
+			bool canMoveDownVanilla = num2 < Main.maxTilesY - 5 && tile2.liquid == 0 && (!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type]);
+			/*
 			while (num2 < Main.maxTilesY - 5 && tile2.liquid == 0 && (!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type])) {
+			*/
+			while (LiquidLoader.CanMoveDown(originX, originY, num, num2 + 1, canMoveDownVanilla)) {
 				num2++;
 				flag4 = true;
 				flag3 = false;
 				tile2 = Main.tile[num, num2 + 1];
+				canMoveDownVanilla = num2 < Main.maxTilesY - 5 && tile2.liquid == 0 && (!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type]);
 			}
 
 			if (WorldGen.gen && flag4 && !flag && !flag2) {
@@ -149,18 +_,22 @@
 			bool flag6 = false;
 			bool flag7 = false;
 			while (true) {
+				//Left or Right tile Check
 				if (Main.tile[num + num5 * num4, num2].liquid == 0) {
 					num6 = num4;
 					num7 = num5;
 				}
 
+				//Check if too close to min/max x
 				if (num4 == -1 && num + num5 * num4 < 5)
 					flag6 = true;
 				else if (num4 == 1 && num + num5 * num4 > Main.maxTilesX - 5)
 					flag5 = true;
 
+				//Check if down tile has the same type of liquid and not full, then transfer liquid to it.
 				tile2 = Main.tile[num + num5 * num4, num2 + 1];
 				if (tile2.liquid != 0 && tile2.liquid != byte.MaxValue && tile2.liquidType() == b) {
+					//Move liquid to the down tile
 					int num8 = 255 - tile2.liquid;
 					if (num8 > num3)
 						num8 = num3;
@@ -171,13 +_,28 @@
 						break;
 				}
 
+				//Potential problem here is that the tile being looked at Main.tile[num, num2] is not always the original tile, and won't have values for
+				//	liquid type or liquid, making it difficult to work with.  May need to have a CanSettleLiquids hook with extra info passed in.
+				bool canMoveDown = num2 < Main.maxTilesY - 5 && tile2.liquid == 0 && (!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type]);
+				int moveX = num + num5 * num4;
+				/*
 				if (num2 < Main.maxTilesY - 5 && tile2.liquid == 0 && (!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type])) {
+				*/
+				if (LiquidLoader.CanMoveDown(moveX, num2, moveX, num2 + 1, canMoveDown)) {
 					flag7 = true;
 					break;
 				}
 
+				//Check horizontal tile.
 				Tile tile3 = Main.tile[num + (num5 + 1) * num4, num2];
+				bool cantMoveHorizontal = (tile3.liquid != 0 && (!flag3 || num4 != 1)) || (tile3.nactive() && Main.tileSolid[tile3.type] && !Main.tileSolidTop[tile3.type]);
+				bool canMoveHorizontalVanilla = !cantMoveHorizontal;
+				int nextMoveX = num + (num5 + 1) * num4;
+				bool canMoveHorizontal = num4 == -1 ? LiquidLoader.CanMoveLeft(num, num2, nextMoveX, num2, canMoveHorizontalVanilla) : LiquidLoader.CanMoveRight(num, num2, nextMoveX, num2, canMoveHorizontalVanilla);
+				/*
 				if ((tile3.liquid != 0 && (!flag3 || num4 != 1)) || (tile3.nactive() && Main.tileSolid[tile3.type] && !Main.tileSolidTop[tile3.type])) {
+				*/
+				if (!canMoveHorizontal) {
 					if (num4 == 1)
 						flag5 = true;
 					else
@@ -338,7 +_,9 @@
 
 		byte liquid = tile5.liquid;
 		float num = 0f;
+
+		LiquidLoader.PreUpdate(tile5.LiquidType, x, y);
-		if (y > Main.UnderworldLayer && tile5.liquidType() == 0 && tile5.liquid > 0) {
+		if (y > Main.UnderworldLayer && LiquidLoader.liquidProperties[tile5.liquidType()].HellEvaporation && tile5.liquid > 0) {
 			byte b = 2;
 			if (tile5.liquid < b)
 				b = tile5.liquid;
@@ -350,7 +_,7 @@
 			kill = 999;
 			return;
 		}
-
+		/*
 		if (tile5.lava()) {
 			LavaCheck(x, y);
 			if (!quickFall) {
@@ -417,8 +_,50 @@
 				}
 			}
 		}
+		*/
 
+		for (int i = 0; i < LiquidLoader.LiquidCount; i++) {
+			if (tile5.LiquidType == i) {
+				if (tile5.LiquidType == LiquidID.Lava) {
+					LavaCheck(x, y);
+				}
+				else {
+					LiquidCheck(x, y, i);
+				}
+				if (!quickFall) {
+					if (delay < LiquidLoader.liquidProperties[i].FallDelay) {
+						delay++;
+						return;
+					}
+
+					delay = 0;
+				}
+				break;
+			} else {
+				if (tile.LiquidType == i)
+					AddWater(x - 1, y);
+
+				if (tile2.LiquidType == i)
+					AddWater(x + 1, y);
+
+				if (tile3.LiquidType == i)
+					AddWater(x, y - 1);
+
+				if (tile4.LiquidType == i)
+					AddWater(x, y + 1);
+			} 
+		}
+
+		if (!LiquidLoader.Update(tile5.LiquidType, this, x, y, tile, tile2, tile3, tile4)) {
+			return;
+		}
+
+		bool canMoveDown = (!tile4.nactive() || !Main.tileSolid[tile4.type] || Main.tileSolidTop[tile4.type]) && (tile4.liquid <= 0 || tile4.liquidType() == tile5.liquidType()) && tile4.liquid < byte.MaxValue;
+		/*
 		if ((!tile4.nactive() || !Main.tileSolid[tile4.type] || Main.tileSolidTop[tile4.type]) && (tile4.liquid <= 0 || tile4.liquidType() == tile5.liquidType()) && tile4.liquid < byte.MaxValue) {
+		*/
+		if (LiquidLoader.CanMoveDown(x, y, x, y + 1, canMoveDown)) {
+			//Move Down
 			bool flag = false;
 			num = 255 - tile4.liquid;
 			if (num > (float)(int)tile5.liquid)
@@ -445,6 +_,9 @@
 		}
 
 		if (tile5.liquid > 0) {
+			CheckMoveLiquidsLeftOrRight(x, y);
+
+			/*
 			bool flag2 = true;
 			bool flag3 = true;
 			bool flag4 = true;
@@ -724,6 +_,7 @@
 
 				tile5.liquid = (byte)num;
 			}
+			*/
 		}
 
 		if (tile5.liquid != liquid) {
@@ -744,7 +_,105 @@
 		else {
 			kill++;
 		}
+
 	}
+
+	//Added by tModLoader
+	private static bool MovePrevented(Tile tile) => tile.HasUnactuatedTile && Main.tileSolid[tile.TileType] && !Main.tileSolidTop[tile.TileType];
+
+	//Added by tModLoader
+	private static bool WillMerge(Tile tile) => tile.LiquidAmount > 0 && tile.LiquidType != tile.LiquidType;
+
+	//Added by tModLoader, written by andro951.
+	//Replaces the code in Update() that moves liquids left and right with loops to make it much easier to work with an insert hooks.
+	//Extra care was taken to make the logic exactly the same as the original even where it seems to be inefficient to prevent potential issues.
+	private static void CheckMoveLiquidsLeftOrRight(int x, int y)
+	{
+		Tile tile = Main.tile[x, y];
+		if (tile.LiquidAmount > 0) {
+			float num = 0f;
+			int numLeft = 0;
+			int numRight = 0;
+			int liquidAmount = 0;
+			for (int i = 1; i <= 3; i++) {
+				int leftX = x - i;
+				Tile tileL = Main.tile[leftX, y];
+				bool canMoveLeft = true;
+				if (MovePrevented(tileL) || WillMerge(tileL)) {
+					canMoveLeft = false;
+				}
+				else if (i > 1 && tileL.LiquidAmount == 0) {
+					canMoveLeft = false;
+				}
+				else if (i == 2 && tile.LiquidAmount > 250) {
+					canMoveLeft = false;
+				}
+				
+				if (LiquidLoader.CanMoveLeft(x, y, leftX, y, canMoveLeft)) {
+					numLeft++;
+					liquidAmount += tileL.LiquidAmount;
+				}
+
+				int rightX = x + i;
+				Tile tileR = Main.tile[rightX, y];
+				bool canMoveRight = true;
+				if (MovePrevented(tileR) || WillMerge(tileR)) {
+					canMoveRight = false;
+				}
+				else if (i > 1 && tileR.LiquidAmount == 0) {
+					canMoveRight = false;
+				}
+				else if (i == 2 && tile.LiquidAmount > 250) {
+					canMoveRight = false;
+				}
+				
+				if (LiquidLoader.CanMoveRight(x, y, rightX, y, canMoveRight)) {
+					numRight++;
+					liquidAmount += tileR.LiquidAmount;
+				}
+
+				if (!canMoveLeft || !canMoveRight)
+					break;
+			}
+				
+			num += tile.LiquidAmount + liquidAmount;
+			if (tile.LiquidAmount < 3)
+				num--;
+
+			byte newAmount = (byte)Math.Round(num / (float)(1 + numLeft + numRight));
+			if (newAmount == byte.MaxValue - 1 && WorldGen.genRand.Next(30) == 0)
+				newAmount = byte.MaxValue;
+				
+			bool anyUpdated = false;
+			int higherNum = Math.Max(numLeft, numRight);
+			for (int i = 1; i <= higherNum; i++) {
+				if (i <= numLeft) {
+					int tileX = x - i;
+					Tile tileL = Main.tile[tileX, y];
+					tileL.LiquidType = tile.LiquidType;
+					if (tileL.LiquidAmount != newAmount || tile.LiquidAmount != newAmount) {
+						tileL.LiquidAmount = newAmount;
+						Liquid.AddWater(tileX, y);
+						anyUpdated = true;
+					}
+				}
+	
+				if (i <= numRight) {
+					int tileX = x + i;
+					Tile tileLR = Main.tile[tileX, y];
+					tileLR.LiquidType = tile.LiquidType;
+					if (tileLR.LiquidAmount != newAmount || tile.LiquidAmount != newAmount) {
+						tileLR.LiquidAmount = newAmount;
+						Liquid.AddWater(tileX, y);
+						anyUpdated = true;
+					}
+				}
+			}
+
+			if (anyUpdated || numLeft < 2 && numRight < 2 || Main.tile[x, y - 1].LiquidAmount <= 0)
+				tile.LiquidAmount = newAmount;
+ 		}
+ 	}
 
 	public static void StartPanic()
 	{
@@ -970,6 +_,21 @@
 		Tile tile5 = Main.tile[x, y];
 		if ((tile.liquid > 0 && tile.liquidType() != thisLiquidType) || (tile2.liquid > 0 && tile2.liquidType() != thisLiquidType) || (tile3.liquid > 0 && tile3.liquidType() != thisLiquidType)) {
 			int num = 0;
+
+			bool[] liquidNearby = new bool[LiquidLoader.LiquidCount];
+
+			if (tile.LiquidAmount > 0) {
+				liquidNearby[tile.LiquidType] = true;
+			}
+
+			if (tile2.LiquidAmount > 0) {
+				liquidNearby[tile2.LiquidType] = true;
+			}
+
+			if (tile3.LiquidAmount > 0) {
+				liquidNearby[tile3.LiquidType] = true;
+			}
+
 			if (tile.liquidType() != thisLiquidType) {
 				num += tile.liquid;
 				tile.liquid = 0;
@@ -987,11 +_,15 @@
 
 			int liquidMergeTileType = 56;
 			int liquidMergeType = 0;
+			/*
 			bool waterNearby = tile.liquidType() == 0 || tile2.liquidType() == 0 || tile3.liquidType() == 0;
 			bool lavaNearby = tile.lava() || tile2.lava() || tile3.lava();
 			bool honeyNearby = tile.honey() || tile2.honey() || tile3.honey();
 			bool shimmerNearby = tile.shimmer() || tile2.shimmer() || tile3.shimmer();
+			*/
+
-			GetLiquidMergeTypes(thisLiquidType, out liquidMergeTileType, out liquidMergeType, waterNearby, lavaNearby, honeyNearby, shimmerNearby);
+			// GetLiquidMergeTypes(thisLiquidType, out liquidMergeTileType, out liquidMergeType, waterNearby, lavaNearby, honeyNearby, shimmerNearby);
+			GetLiquidMergeTypes(thisLiquidType, out liquidMergeTileType, out liquidMergeType, liquidNearby);
 			if (num < 24 || liquidMergeType == thisLiquidType)
 				return;
 
@@ -1003,6 +_,7 @@
 
 			if (!tile5.active()) {
 				tile5.liquid = 0;
+				/*
 				switch (thisLiquidType) {
 					case 1:
 						tile5.lava(lava: false);
@@ -1014,6 +_,8 @@
 						tile5.shimmer(shimmer: false);
 						break;
 				}
+				*/
+				tile5.LiquidType = 0;
 
 				TileChangeType liquidChangeType = WorldGen.GetLiquidChangeType(thisLiquidType, liquidMergeType);
 				if (!WorldGen.gen)
@@ -1058,12 +_,23 @@
 
 			int liquidMergeTileType2 = 56;
 			int liquidMergeType2 = 0;
+			/*
 			bool waterNearby2 = tile4.liquidType() == 0;
 			bool lavaNearby2 = tile4.lava();
 			bool honeyNearby2 = tile4.honey();
 			bool shimmerNearby2 = tile4.shimmer();
-			GetLiquidMergeTypes(thisLiquidType, out liquidMergeTileType2, out liquidMergeType2, waterNearby2, lavaNearby2, honeyNearby2, shimmerNearby2);
+			*/
+			bool[] liquidNearby = new bool[LiquidLoader.LiquidCount];
+
+			if(tile4.LiquidAmount > 0) {
+				liquidNearby[tile4.LiquidType] = true;
+			}
+			
+
+			// GetLiquidMergeTypes(thisLiquidType, out liquidMergeTileType, out liquidMergeType, waterNearby, lavaNearby, honeyNearby, shimmerNearby);
+			GetLiquidMergeTypes(thisLiquidType, out liquidMergeTileType2, out liquidMergeType2, liquidNearby);
 			tile5.liquid = 0;
+			/*
 			switch (thisLiquidType) {
 				case 1:
 					tile5.lava(lava: false);
@@ -1075,6 +_,8 @@
 					tile5.shimmer(shimmer: false);
 					break;
 			}
+			*/
+			tile5.LiquidType = 0;
 
 			tile4.liquid = 0;
 			TileChangeType liquidChangeType2 = WorldGen.GetLiquidChangeType(thisLiquidType, liquidMergeType2);
@@ -1088,11 +_,12 @@
 		}
 	}
 
-	public static void GetLiquidMergeTypes(int thisLiquidType, out int liquidMergeTileType, out int liquidMergeType, bool waterNearby, bool lavaNearby, bool honeyNearby, bool shimmerNearby)
+	//public static void GetLiquidMergeTypes(int thisLiquidType, out int liquidMergeTileType, out int liquidMergeType, bool waterNearby, bool lavaNearby, bool honeyNearby, bool shimmerNearby)
+	public static void GetLiquidMergeTypes(int thisLiquidType, out int liquidMergeTileType, out int liquidMergeType, bool[] liquidNearby)
 	{
 		liquidMergeTileType = 56;
 		liquidMergeType = thisLiquidType;
-		if (thisLiquidType != 0 && waterNearby) {
+		if (thisLiquidType != LiquidID.Water && liquidNearby[LiquidID.Water]) {
 			switch (thisLiquidType) {
 				case 1:
 					liquidMergeTileType = 56;
@@ -1108,7 +_,7 @@
 			liquidMergeType = 0;
 		}
 
-		if (thisLiquidType != 1 && lavaNearby) {
+		if (thisLiquidType != LiquidID.Lava && liquidNearby[LiquidID.Lava]) {
 			switch (thisLiquidType) {
 				case 0:
 					liquidMergeTileType = 56;
@@ -1124,7 +_,7 @@
 			liquidMergeType = 1;
 		}
 
-		if (thisLiquidType != 2 && honeyNearby) {
+		if (thisLiquidType != LiquidID.Honey && liquidNearby[LiquidID.Honey]) {
 			switch (thisLiquidType) {
 				case 0:
 					liquidMergeTileType = 229;
@@ -1140,7 +_,7 @@
 			liquidMergeType = 2;
 		}
 
-		if (thisLiquidType != 3 && shimmerNearby) {
+		if (thisLiquidType != LiquidID.Shimmer && liquidNearby[LiquidID.Shimmer]) {
 			switch (thisLiquidType) {
 				case 0:
 					liquidMergeTileType = 659;
@@ -1155,6 +_,8 @@
 
 			liquidMergeType = 3;
 		}
+
+		LiquidLoader.Merge(thisLiquidType, liquidNearby, ref liquidMergeTileType, ref liquidMergeType);
 	}
 
 	public static void LavaCheck(int x, int y)
